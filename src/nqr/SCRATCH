# Copyright (C) 2010, Parrot Foundation.
# Copyright (C) 2011, Michael Kane and John Emerson.

# This is just a scratch file for various notes and working
# code that we didn't place in Runtime.pm at this point.
# However, just because something is in Runtime.pm doesn't
# necessarily mean we're happy with it!  But it probably
# works at some level (even if imperfectly).




sub myrexp($arg) {
  my $ans;
  my libRmath := pir::loadlib("libRmath");
  my rexp := pir::dlfunc(libRmath, "rexp", "dd");
  $ans := 0;
  return $ans;
}


  #my libRmath := pir::loadlib("libRmath");
  #my rexp := pir::dlfunc(libRmath, "rexp", "dd");
  #my ans := 0;






https://github.com/perl6/nqp/tree/master/t/nqp
(specifically, https://github.com/perl6/nqp/blob/master/t/nqp/28-subclass.t )


# Earlier... might be close, returns PMC rather than scalar.
#sub length(*@args) {
#    my @arg := @args[0];
#    my @len;
#    @len[0] := +@arg;
#    return @len;
#}

# Consider a vector class.

#######################
# Extras, working area:

# length of an array:
    #my $len := @args;
    #pir::say($len);

#sub print(*@args) {
#    my $arg := @args[0];
#    pir::say(pir::join(' ', $arg));
#    pir::return();
#}

# From Will Coleda:
our multi sub print(ResizablePMCArray @args) {
  say("ResizablePMCArray");
  say(pir::join(' ', @args));
}

our multi sub print($arg) {
  print("$arg");
  say($arg);
}


######################################
# length(): assumes only one argument:

sub length(*@args) {
    my @arg := @args[0];
    my $len := @arg;
    pir::say($len);
    pir::return();
}

#################################################################
# print()
#
# Working version of print, which only prints the first argument,
# whatever that is, and ignores any other arguments.
# Hmm... not quite, try it on the answer of a length().
sub print(*@args) {
    my $arg := @args[0];
    pir::say(pir::join(' ', $arg));
    pir::return();
}

################################################################
# length()
#
# Only try to process the length of the first argument?  No,
# if the element is a scalar, it just gets that number.  Argh...
# And of course we really want to consider all arguments.
sub length(*@args) {
    my $len := Q:PIR {
      $P0 = find_lex '@args'
      $P1 = $P0[0]
      $I0 = -1
      if null $P1 goto errormessage
        $I0 = elements $P1
        goto nowwearedone
      errormessage:
        say 'Error in length'
      nowwearedone:
      %r = box $I0
    };
    pir::say($len);
    pir::return($len);
}



################################################################
# c()
#
# Oooo... simple enough, even though we aren't micro-managing
# the data structure.  And of course it really isn't quite right
# except for the easy cases.
sub c(*@args) {
  pir::return(@args);
}

# This could be our c() in a minimal version I suppose:
#sub asvector(*@args) {
#    my @ans := Q:PIR {
#      .local pmc array
#      array = new 'FixedIntegerArray'
#      array = 5
#      array[0] = -1
#      array[4] = 99
#      %r = array
#    };
#    #my $len := pir::elements(@ans);
#    #print($len);
#    pir::return(@ans);
#}

#########################################################
# Jay playing around:

sub myprint(*@args) {
    print(@args[0]);
    pir::return();
}

sub myprint2(*@args) {
    for (@args[0]) {
      print($_);
    }
    pir::return();
}

# This may be closest, since R only prints the first argument...
# Then really need c() or paste() to achieve the desired testing calls...
sub myprint3(*@args) {
    pir::say(pir::join(' ', @args[0]));
    pir::return();
}

# Null PMC access in get_string():
# This only works if every cell of the array has a value?
# Would be really nice to know what NQP really is...
sub myprint4(*@args) {
    my $temp;
    for (@args[0]) {
      $temp := $_;
      if ($temp eq '') { $temp := 'NA'; }
      pir::say($temp);
    }
    pir::return();
}

# Imbed PIR in the function; much closer to R's print.
# Oops, maybe not.  Incomplete.
sub myprint5(*@args) {
    my @temp := @args[0];
    Q:PIR {
        .local pmc it
        .local pmc x
        x = find_lex '@temp'
        it = iter x
      iter_loop:
        unless it goto iter_end
        $S0 = shift it
        $S0 = $S0 . ' '
        print $S0
        goto iter_loop
      iter_end:
        print "\n"
    };
    pir::return();
}

#######################################################################
# seq()
#

# This runs into trouble, I think, because the push is pushing a
# pointer that isn't actually evaluated until the end, so something
# like seqPIRbad(1,10,3) would give 13, 13, 13, 13.
sub seqPIRbad(*@args) {
  return Q:PIR {
      .local pmc i, to, by
      $P0 = new "ResizablePMCArray" # Will be the answer
      $P1 = new "ResizablePMCArray" # Will hold the arguments
      $P1 = find_lex '@args'
      i = $P1[0]  # the start and the index
      to = $P1[1] # the end
      by = $P1[2] # the by
      iter_loop:
        unless i<=to goto iter_end
        push $P0, i
        i += by
        goto iter_loop
      iter_end: 
      %r = $P0
  };
}

# Using only PIR:
sub seqPIR(*@args) {
  return Q:PIR {
      .local num i, to, by
      $P0 = new "ResizablePMCArray" # Will be the answer
      $P1 = new "ResizablePMCArray" # Will hold the arguments
      $P1 = find_lex '@args'
      i = $P1[0]  # the start and the index
      to = $P1[1] # the end
      by = $P1[2] # the by
      iter_loop:
        unless i<=to goto iter_end
        push $P0, i
        i += by
        goto iter_loop
      iter_end: 
      %r = $P0
  };
}




# Not working.  Need to get around this scalar/array distinction which
# is annoying, and find length of an array?  Really need vectors.
sub rep(*@args) {
  my @val := @args[0];
  my $times := @args[1];
  my @ans;
  my $i;
  my $j;
  $i := $times - 1;
  while ($i>0) {
    $j := (@val) - 1;
    while ($j>0) {
      @ans[$i * $times + $j] := @val[$j];
      $j := $j - 1;
    }
    $i := $i - 1;
  }
  pir::return(@ans);
}




Important stuff: function calls, nci

$ nm libparrot.so|grep dlfunc
0000000000140400 t _Z21Parrot_dlfunc_p_p_s_pPlP15parrot_interp_t
000000000013f610 t _Z21Parrot_dlfunc_p_p_s_sPlP15parrot_interp_t
000000000013fd00 t _Z22Parrot_dlfunc_p_p_s_scPlP15parrot_interp_t
0000000000140770 t _Z22Parrot_dlfunc_p_p_sc_pPlP15parrot_interp_t
000000000013f980 t _Z22Parrot_dlfunc_p_p_sc_sPlP15parrot_interp_t
0000000000140080 t _Z23Parrot_dlfunc_p_p_sc_scPlP15parrot_interp_t



 jay: have a look at this: https://github.com/letolabs/parrot-libgit2/blob/master/src/git2.pir
<dukeleto> jay: that is actually generated code, from the tools/dev/ncidef2pir.pl tool
<soh_cah_toa> i thought the syntax in nqp was pir::foo__PPPS()?
<soh_cah_toa> or maybe i'm thinking of something else
<dukeleto> jay: yes, it is a double underscore
<jay> soh_cah_toa++   !   Compiled.
<soh_cah_toa> first one is return type, the rest are args
<soh_cah_toa> yay me
<dukeleto> jay: and args+function return are mostly lowercase. 
<soh_cah_toa> actually, i don't know the difference between the uppercase/lowercase variants
<jay> I used upper here.  Is lower preferred?
<dukeleto> jay: they mean slightly different things
* jsut has quit (Ping timeout: 360 seconds)
<dukeleto> jay: which I can't remember, nor where they are documented :(
<dukeleto> jay: parrots function signatures are documented a bit in docs/embed.pod
* fperrad (~chatzilla@AToulon-552-1-66-107.w90-37.abo.wanadoo.fr) has joined #parrot
* slavorg gives channel operator status to fperrad
<soh_cah_toa> yes, that's where it is
<soh_cah_toa> also docs/embed_new.pod
<dukeleto> jay: this https://github.com/letolabs/parrot-libgit2/blob/master/src/git2.nci is a file which describes external library functions arguments and return values, and then a script generates the PIR I showed you above
<cotto> dukeleto, https://github.com/parrot/parrot/blob/master/compilers/pct/src/PAST/Compiler.pir
<dukeleto> jay: if you have dozens or hundres of functions, it really shines
<bubaflub> dukeleto: amen.


# bubaflub
 Suppose I have a lot of dlfuncs all coming from the same library... can I do a loadlib once and put the resulting library "handle" or whatever it is into a global?
<bubaflub> jay: https://github.com/bubaflub/parrot-gmp/blob/master/src/GMP/raw.pir
<jay> bubaflub++  Same link as last night but I was looking at something else there I think.  Thanks!
<bubaflub> jay: ok.  this is in PIR and is generated from a script in parrot under tools/dev/ncidef2pir.pl
<bubaflub> jay: i have a NCI definition file (https://github.com/bubaflub/parrot-gmp/blob/master/src/GMP/raw.nci) and the script outputs the PIR.  pretty simple but saves me some time

jay: that's exactly what my project is doing - i've got a script that reads gmp.h and generates the NCI definition.  from there we've got a script in parrot that goes from NCI def -> PIR.
<bubaflub> jay: each header file is slightly different and GMP had a bunch of #define's i had to work around, but you could probably take my script and modify it to work with GSL


 what you really need is an NCI thunk to provide the Parrot/C interface for the call you are trying to make
<plobsing> you can do that by compiling Parrot with libffi, providing a dynamic thunk library, or rebuilding parrot with additional core thunks.

jay: basically, not every possible combination of signatures is currently covered.  either generate a thunk (using parrot_nci_thunk_gen) or use libffi.

jay: in other news, GSL also has the same documentation format (textinfo) so there is a change that the scripts i use for GMP will work with minimal convers


https://github.com/bubaflub/parrot-gmp/blob/master/src/GMP/raw.pir


plobsing: while you're here - is there an example of somewhere that uses parrot_nci_thunk_gen and loads in those libraries?
<bubaflub> s/libraries/thunks/g

and see opengl bindings?
so you'll likely want to look at runtime/parrot/library/OpenGL.pir, and sections of Parrot's makefile concerning 'glut_nci_thunks'

plobsing: ok, i think i get it.  i give it a slightly different NCI definition file, use nci_thunk_gen with --loader-name and generate the C.  compile the C into a library, and then load that library and call whatever function name i specified in --loader-name.

bubaflub: IIRC, there is some magic so that if you do not provide a --loader-name, it picks a special name for the loader and you don't have to call it (parrot calls it automatically as part of the library load)
plobsing: ok.  so maybe just the --dynext param needed then?














